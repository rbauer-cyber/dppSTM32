//$file${.::terminal.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: dpp.qm
// File:  ${.::terminal.cpp}
//
// This code has been generated by QM 7.0.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (C) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// The QP/C++ software is dual-licensed under the terms of the open-source
// GNU General Public License (GPL) or under the terms of one of the closed-
// source Quantum Leaps commercial licenses.
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::terminal.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"             // QP/C++ real-time embedded framework
#include "dpp.hpp"               // DPP Application interface
#include "bsp.hpp"               // Board Support Package

#include "console.h"
#include "multiLed.hpp"

//----------------------------------------------------------------------------
// unnamed namespace for local definitions with internal linkage
namespace {
Q_DEFINE_THIS_FILE

}

//----------------------------------------------------------------------------
//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U)%0x2710U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${Shared::AO_Terminal} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${Shared::AO_Terminal} .....................................................
QP::QActive * const AO_Terminal = &Terminal::inst;

} // namespace APP
//$enddef${Shared::AO_Terminal} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//$define${AOs::Terminal} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace APP {

//${AOs::Terminal} ...........................................................
Terminal Terminal::inst;

//${AOs::Terminal::Terminal} .................................................
Terminal::Terminal()
  : QActive(Q_STATE_CAST(&initial)),
    m_timeEvt(this, TIMEOUT_SIG, 0U)
{}

//${AOs::Terminal::DispatchCommand} ..........................................
void Terminal::DispatchCommand(char command) {
    consoleDisplay("Empty Dispatch command\r\n");
}

//${AOs::Terminal::SM} .......................................................
Q_STATE_DEF(Terminal, initial) {
    //${AOs::Terminal::SM::initial}
    //consoleDisplay("Terminal running\r\n");
    m_maxInputSize = sizeof(m_input)/sizeof(m_input[0]);
    return tran(&start);
}

//${AOs::Terminal::SM::start} ................................................
Q_STATE_DEF(Terminal, start) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::start}
        case Q_ENTRY_SIG: {
            //consoleDisplay("Terminal ::Idle\r\n");
            m_timeEvt.armX(1000, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::start}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::start::TIMEOUT}
        case TIMEOUT_SIG: {
            status_ = tran(&sendUserPrompt);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

//${AOs::Terminal::SM::receiveUserReply} .....................................
Q_STATE_DEF(Terminal, receiveUserReply) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::receiveUserReply}
        case Q_ENTRY_SIG: {
            //consoleDisplay("Terminal ::Receiving USART\r\n");
            m_gotReply = false;
            m_gotChar = false;
            m_replySize = 0;
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::receiveUserReply::initial}
        case Q_INIT_SIG: {
            m_gotReply = false;
            m_gotChar = true;
            m_replySize = 0;

            consoleReadAsyncInit();
            status_ = tran(&receivingNextChar);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

//${AOs::Terminal::SM::receiveUserReply::receivingNextChar} ..................
Q_STATE_DEF(Terminal, receivingNextChar) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::receiveUserReply::receivingNextChar}
        case Q_ENTRY_SIG: {
            if ( m_gotChar )
            {
                m_gotChar = false;
                consoleReadByteAsync();
            }

            m_timeEvt.armX(300, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::receiveUserReply::receivingNextChar}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::receiveUserReply::receivingNextCha~::TIMEOUT}
        case TIMEOUT_SIG: {
            m_gotChar = (consoleInputReady()) ? true : false;

            if ( m_gotChar )
            {
                m_gotReply = (consoleInputDone()) ? true : false;
            }
            //${AOs::Terminal::SM::receiveUserReply::receivingNextCha~::TIMEOUT::[NotDone]}
            if (!m_gotReply) {
                status_ = tran(&receivingNextChar);
            }
            //${AOs::Terminal::SM::receiveUserReply::receivingNextCha~::TIMEOUT::[GotReply]}
            else if (m_gotReply) {
                m_replySize = consoleReadString(m_input, m_maxInputSize);
                consoleDisplay("\r\n");
                consoleDisplay(m_input);
                this->DispatchCommand(m_input[0]);
                status_ = tran(&sendUserPrompt);
            }
            else {
                status_ = Q_RET_UNHANDLED;
            }
            break;
        }
        default: {
            status_ = super(&receiveUserReply);
            break;
        }
    }
    return status_;
}

//${AOs::Terminal::SM::sendUserPrompt} .......................................
Q_STATE_DEF(Terminal, sendUserPrompt) {
    QP::QState status_;
    switch (e->sig) {
        //${AOs::Terminal::SM::sendUserPrompt}
        case Q_ENTRY_SIG: {
            m_timeEvt.armX(500, 0U);
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::sendUserPrompt}
        case Q_EXIT_SIG: {
            m_timeEvt.disarm();
            status_ = Q_RET_HANDLED;
            break;
        }
        //${AOs::Terminal::SM::sendUserPrompt::TIMEOUT}
        case TIMEOUT_SIG: {
            consoleDisplay("Enter command: ");
            status_ = tran(&receiveUserReply);
            break;
        }
        default: {
            status_ = super(&top);
            break;
        }
    }
    return status_;
}

} // namespace APP
//$enddef${AOs::Terminal} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
